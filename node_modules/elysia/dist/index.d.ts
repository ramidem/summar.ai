/// <reference types="bun-types" />
import type { Serve, Server } from 'bun';
import { SCHEMA, EXPOSED, DEFS } from './utils';
import type { Context } from './context';
import type { ElysiaWSOptions, WSTypedSchema } from './ws';
import type { Handler, BeforeRequestHandler, TypedRoute, ElysiaInstance, ElysiaConfig, HTTPMethod, InternalRoute, BodyParser, ErrorHandler, TypedSchema, LocalHook, LocalHandler, LifeCycle, LifeCycleEvent, LifeCycleStore, VoidLifeCycle, AfterRequestHandler, IsAny, OverwritableTypeRoute, MergeSchema, ListenCallback, NoReturnHandler, MaybePromise, IsNever, Prettify, TypedWSRouteToEden, UnwrapSchema, ExtractPath, TypedSchemaToRoute, DeepWritable } from './types';
import { Static, type TSchema } from '@sinclair/typebox';
import type { ValidationError, ParseError, NotFoundError, InternalServerError } from './error';
import type { Permission } from '@elysiajs/fn';
export default class Elysia<Instance extends ElysiaInstance = ElysiaInstance> {
    config: ElysiaConfig;
    store: Instance['store'];
    meta: Instance['meta'];
    protected decorators: ElysiaInstance['request'];
    event: LifeCycleStore<Instance>;
    server: Server | null;
    private $schema;
    private router;
    protected routes: InternalRoute<Instance>[];
    private staticRouter;
    private wsRouter;
    private lazyLoadModules;
    constructor(config?: Partial<ElysiaConfig>);
    private add;
    onStart(handler: VoidLifeCycle<Instance>): this;
    onRequest<Route extends OverwritableTypeRoute = TypedRoute>(handler: BeforeRequestHandler<Route, Instance>): this;
    onParse(parser: BodyParser<any, Instance>): this;
    onTransform<Route extends OverwritableTypeRoute = TypedRoute>(handler: NoReturnHandler<Route, Instance>): this;
    onBeforeHandle<Route extends OverwritableTypeRoute = TypedRoute>(handler: Handler<Route, Instance>): this;
    onAfterHandle<Route extends OverwritableTypeRoute = TypedRoute>(handler: AfterRequestHandler<Route, Instance>): this;
    onError(errorHandler: ErrorHandler): this;
    onStop(handler: VoidLifeCycle<Instance>): this;
    on<Event extends LifeCycleEvent = LifeCycleEvent>(type: Event, handler: LifeCycle<Instance>[Event]): this;
    group<NewElysia extends Elysia<any> = Elysia<any>, Prefix extends string = string>(prefix: Prefix, run: (group: Elysia<{
        request: Instance['request'];
        store: Omit<Instance['store'], typeof SCHEMA> & ElysiaInstance['store'];
        schema: Instance['schema'];
        meta: Omit<Instance['meta'], typeof SCHEMA> & ElysiaInstance['meta'];
    }>) => NewElysia): NewElysia extends Elysia<infer NewInstance> ? Elysia<{
        request: Instance['request'];
        schema: Instance['schema'];
        store: Instance['store'];
        meta: Instance['meta'] & (Omit<NewInstance['meta'], typeof SCHEMA> & Record<typeof SCHEMA, {
            [key in keyof NewInstance['meta'][typeof SCHEMA] as key extends `${infer Rest}` ? `${Prefix}${Rest}` : key]: NewInstance['meta'][typeof SCHEMA][key];
        }>);
    }> : this;
    group<Schema extends TypedSchema<Exclude<keyof Instance['meta'][typeof DEFS], number | symbol>>, NewElysia extends Elysia<any> = Elysia<any>, Prefix extends string = string>(prefix: Prefix, schema: LocalHook<Schema, Instance>, run: (group: Elysia<{
        request: Instance['request'];
        store: Omit<Instance['store'], typeof SCHEMA> & ElysiaInstance['store'];
        schema: Schema & Instance['schema'];
        meta: Omit<Instance['meta'], typeof SCHEMA> & ElysiaInstance['meta'];
    }>) => NewElysia): NewElysia extends Elysia<infer NewInstance> ? Elysia<{
        request: Instance['request'];
        schema: Instance['schema'];
        store: Instance['store'];
        meta: Instance['meta'] & (Omit<NewInstance['meta'], typeof SCHEMA> & Record<typeof SCHEMA, {
            [key in keyof NewInstance['meta'][typeof SCHEMA] as key extends `${infer Rest}` ? `${Prefix}${Rest}` : key]: NewInstance['meta'][typeof SCHEMA][key];
        }>);
    }> : this;
    guard<Schema extends TypedSchema<Exclude<keyof Instance['meta'][typeof DEFS], number | symbol>>, NewElysia extends Elysia<any> = Elysia<any>>(hook: LocalHook<Schema, Instance>, run: (group: Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Schema & Instance['schema'];
        meta: Instance['meta'];
    }>) => NewElysia): NewElysia extends Elysia<infer NewInstance> ? Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'] & NewInstance['schema'];
        meta: Instance['meta'] & Record<typeof SCHEMA, {
            [key in keyof NewInstance['meta'][typeof SCHEMA]]: NewInstance['meta'][typeof SCHEMA][key];
        }>;
    }> : this;
    use<NewElysia extends MaybePromise<Elysia<any>> = Elysia<any>, Params extends Elysia = Elysia<any>, LazyLoadElysia extends never | ElysiaInstance = never>(plugin: MaybePromise<(app: Params extends Elysia<infer ParamsInstance> ? IsAny<ParamsInstance> extends true ? this : Params : Params) => MaybePromise<NewElysia>> | Promise<{
        default: (elysia: Elysia<any>) => MaybePromise<Elysia<LazyLoadElysia>>;
    }>): IsNever<LazyLoadElysia> extends false ? Elysia<{
        request: Instance['request'] & LazyLoadElysia['request'];
        store: Instance['store'] & LazyLoadElysia['store'];
        schema: Instance['schema'] & LazyLoadElysia['schema'];
        meta: Instance['meta'] & LazyLoadElysia['meta'];
    }> : NewElysia extends Elysia<infer NewInstance> ? IsNever<NewInstance> extends true ? Elysia<Instance> : Elysia<{
        request: Instance['request'] & NewInstance['request'];
        store: Instance['store'] & NewInstance['store'];
        schema: Instance['schema'] & NewInstance['schema'];
        meta: Instance['meta'] & NewInstance['meta'];
    }> : NewElysia extends Promise<Elysia<infer NewInstance>> ? Elysia<{
        request: Instance['request'] & NewInstance['request'];
        store: Instance['store'] & NewInstance['store'];
        schema: Instance['schema'] & NewInstance['schema'];
        meta: Instance['meta'] & NewInstance['meta'];
    }> : this;
    if<Condition extends boolean, NewElysia extends MaybePromise<Elysia<any>> = Elysia<any>, Params extends Elysia = Elysia<any>, LazyLoadElysia extends never | ElysiaInstance = never>(condition: Condition, run: MaybePromise<(app: Params extends Elysia<infer ParamsInstance> ? IsAny<ParamsInstance> extends true ? this : Params : Params) => MaybePromise<NewElysia>> | Promise<{
        default: (elysia: Elysia<any>) => MaybePromise<Elysia<LazyLoadElysia>>;
    }>): IsNever<LazyLoadElysia> extends false ? Elysia<{
        request: Instance['request'] & LazyLoadElysia['request'];
        store: Instance['store'] & LazyLoadElysia['store'];
        schema: Instance['schema'] & LazyLoadElysia['schema'];
        meta: Instance['meta'] & LazyLoadElysia['meta'];
    }> : NewElysia extends Elysia<infer NewInstance> ? IsNever<NewInstance> extends true ? Elysia<Instance> : Elysia<{
        request: Instance['request'] & NewInstance['request'];
        store: Instance['store'] & NewInstance['store'];
        schema: Instance['schema'] & NewInstance['schema'];
        meta: Instance['meta'] & NewInstance['meta'];
    }> : NewElysia extends Promise<Elysia<infer NewInstance>> ? Elysia<{
        request: Instance['request'] & NewInstance['request'];
        store: Instance['store'] & NewInstance['store'];
        schema: Instance['schema'] & NewInstance['schema'];
        meta: Instance['meta'] & NewInstance['meta'];
    }> : this;
    get<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                get: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    post<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                post: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    put<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                put: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    patch<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                patch: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    delete<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                delete: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    options<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                options: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    all<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                all: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    head<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                head: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    trace<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                trace: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    connect<Path extends string, Handler extends LocalHandler<Schema, Instance, Path>, Schema extends TypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, handler: Handler, hook?: LocalHook<Schema, Instance, Path>): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                connect: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    ws<Path extends string, Schema extends WSTypedSchema<Extract<keyof Instance['meta'][typeof DEFS], string>>>(path: Path, options: Path extends '' ? never : this extends Elysia<infer Instance> ? ElysiaWSOptions<Path, Schema, Instance['meta'][typeof DEFS]> : never): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Instance['meta'] & Record<typeof SCHEMA, Record<Path, MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            subscribe: TypedWSRouteToEden<Typed, Instance['meta'][typeof DEFS], Path>;
        } : {}>>;
    }>;
    route<Schema extends TypedSchema<Exclude<keyof Instance['meta'][typeof DEFS], number | symbol>>, Method extends HTTPMethod = HTTPMethod, Path extends string = string, Handler extends LocalHandler<Schema, Instance, Path> = LocalHandler<Schema, Instance, Path>>(method: Method, path: Path, handler: Handler, { config, ...hook }?: LocalHook<Schema, Instance, Path> & {
        config: {
            allowMeta?: boolean;
        };
    }): Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED]> & Record<typeof SCHEMA, Prettify<Instance['meta'][typeof SCHEMA] & MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in Path]: {
                [method in Method]: {
                    body: UnwrapSchema<Typed['body'], Instance['meta'][typeof DEFS]>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta'][typeof DEFS]> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Path>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta'][typeof DEFS], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : never>>;
    }>;
    state<Key extends string | number | symbol, Value>(name: Key, value: Value): Elysia<{
        store: Instance['store'] & {
            [key in Key]: Value;
        };
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    state<NewStore extends Record<string, unknown>>(store: NewStore): Elysia<{
        store: Instance['store'] & DeepWritable<NewStore>;
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    decorate<const Name extends string, const Value>(name: Name, value: Value): Elysia<{
        store: Instance['store'];
        request: Instance['request'] & {
            [key in Name]: Value;
        };
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    decorate<const Decorators extends Record<string, unknown>>(name: Decorators): Elysia<{
        store: Instance['store'];
        request: Instance['request'] & DeepWritable<Decorators>;
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    derive<Returned extends Object = Object>(transform: (context: Context<TypedSchemaToRoute<Instance['schema'], Instance['meta'][typeof DEFS]>, Instance['store']> & Instance['request']) => MaybePromise<Returned> extends {
        store: any;
    } ? never : Returned): Elysia<{
        store: Instance['store'];
        request: Instance['request'] & Awaited<Returned>;
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    fn<PluginInstalled extends boolean = IsAny<Permission> extends true ? false : true, T extends PluginInstalled extends true ? Record<string, unknown> | ((app: Instance['request'] & {
        store: Instance['store'];
        permission: Permission;
    }) => Record<string, unknown>) : "Please install '@elysiajs/fn' before using Elysia Fn" = PluginInstalled extends true ? Record<string, unknown> | ((app: Instance['request'] & {
        store: Instance['store'];
        permission: Permission;
    }) => Record<string, unknown>) : "Please install '@elysiajs/fn' before using Elysia Fn">(value: T): PluginInstalled extends true ? Elysia<{
        store: Instance['store'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Record<typeof DEFS, Instance['meta'][typeof DEFS]> & Record<typeof EXPOSED, Instance['meta'][typeof EXPOSED] & (T extends (store: any) => infer Returned ? Returned : T)> & Record<typeof SCHEMA, Instance['meta'][typeof SCHEMA]>;
    }> : this;
    schema<Schema extends TypedSchema<Exclude<keyof Instance['meta'][typeof DEFS], number | symbol>> = TypedSchema<Exclude<keyof Instance['meta'][typeof DEFS], number | symbol>>, NewInstance = Elysia<{
        request: Instance['request'];
        store: Instance['store'];
        schema: MergeSchema<Schema, Instance['schema']>;
        meta: Instance['meta'];
    }>>(schema: Schema): NewInstance;
    compile(): this;
    handle: (request: Request) => Promise<Response>;
    fetch: (request: Request) => MaybePromise<Response>;
    handleError: (request: Request, error: Error | ValidationError | ParseError | NotFoundError | InternalServerError, set: Context['set']) => Promise<any>;
    private outerErrorHandler;
    listen: (options: string | number | Partial<Serve>, callback?: ListenCallback) => this;
    stop: () => Promise<void>;
    get modules(): Promise<Elysia<any>[]>;
    model<Name extends string, Model extends TSchema>(name: Name, model: Model): Elysia<{
        store: Instance['store'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'] & Record<typeof DEFS, {
            [name in Name]: Static<Model>;
        }>;
    }>;
    model<Recorder extends Record<string, TSchema>>(record: Recorder): Elysia<{
        store: Instance['store'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'] & Record<typeof DEFS, {
            [key in keyof Recorder]: Static<Recorder[key]>;
        }>;
    }>;
}
export { Elysia };
export { t } from './custom-types';
export { ws } from './ws';
export { SCHEMA, DEFS, EXPOSED, getSchemaValidator, mergeDeep, mergeHook, mergeObjectArray, getResponseSchemaValidator } from './utils';
export { ParseError, NotFoundError, ValidationError, InternalServerError } from './error';
export type { Context, PreContext } from './context';
export type { Handler, RegisteredHook, BeforeRequestHandler, TypedRoute, OverwritableTypeRoute, ElysiaInstance, ElysiaConfig, HTTPMethod, ComposedHandler, InternalRoute, BodyParser, ErrorHandler, ErrorCode, TypedSchema, LocalHook, LocalHandler, LifeCycle, LifeCycleEvent, AfterRequestHandler, HookHandler, TypedSchemaToRoute, UnwrapSchema, LifeCycleStore, VoidLifeCycle, SchemaValidator, ExtractPath, IsPathParameter, IsAny, IsNever, UnknownFallback, WithArray, ObjectValues, MaybePromise, MergeIfNotNull, ElysiaDefaultMeta, AnyTypedSchema, DeepMergeTwoTypes } from './types';
