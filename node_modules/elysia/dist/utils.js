import{Kind as e}from"@sinclair/typebox";import{TypeCompiler as r}from"@sinclair/typebox/compiler";export const SCHEMA=Symbol("schema");export const DEFS=Symbol("definitions");export const EXPOSED=Symbol("exposed");export const mergeObjectArray=(e,r)=>[...Array.isArray(e)?e:[e],...Array.isArray(r)?r:[r]];export const mergeHook=(e,r)=>({body:r?.body??e?.body,headers:r?.headers??e?.headers,params:r?.params??e?.params,query:r?.query??e?.query,response:r?.response??e?.response,detail:mergeDeep(r?.detail??{},e?.detail??{}),transform:mergeObjectArray(e.transform??[],r?.transform??[]),beforeHandle:mergeObjectArray(e.beforeHandle??[],r?.beforeHandle??[]),parse:mergeObjectArray(e.parse??[],r?.parse??[]),afterHandle:mergeObjectArray(e.afterHandle??[],r?.afterHandle??[]),error:mergeObjectArray(e.error??[],r?.error??[]),type:e?.type||r?.type});let t=e=>e&&"object"==typeof e&&!Array.isArray(e);export const mergeDeep=(e,r)=>{let o=Object.assign({},e);return t(e)&&t(r)&&Object.keys(r).forEach(a=>{t(r[a])&&a in e?o[a]=mergeDeep(e[a],r[a]):Object.assign(o,{[a]:r[a]})}),o};export const getSchemaValidator=(e,t,o=!1)=>{if(!e||"string"==typeof e&&!(e in t))return;let a="string"==typeof e?t[e]:e;return"object"===a.type&&"additionalProperties"in a==!1&&(a.additionalProperties=o),r.Compile(a)};export const getResponseSchemaValidator=(t,o,a=!1)=>{if(!t||"string"==typeof t&&!(t in o))return;let i="string"==typeof t?o[t]:t;if(e in i)return{200:r.Compile(i)};let n={};return Object.keys(i).forEach(t=>{let s=i[t];if("string"==typeof s){if(s in o){let a=o[s];a.type,n[+t]=e in a?r.Compile(a):a}return}"object"===s.type&&"additionalProperties"in s==!1&&(s.additionalProperties=a),n[+t]=e in s?r.Compile(s):s}),n};