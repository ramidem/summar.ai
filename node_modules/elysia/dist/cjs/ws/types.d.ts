/// <reference types="bun-types" />
import type { ServerWebSocket, WebSocketHandler } from 'bun';
import type { TObject, TSchema } from '@sinclair/typebox';
import type { TypeCheck } from '@sinclair/typebox/compiler';
import type { Context } from '../context';
import type { DEFS } from '../utils';
import type { ElysiaInstance, UnwrapSchema, ExtractPath, WithArray, NoReturnHandler, HookHandler } from '../types';
import type { ElysiaWS } from '.';
export interface WSTypedSchema<ModelName extends string = string> {
    body?: TSchema | ModelName;
    headers?: TObject | ModelName;
    query?: TObject | ModelName;
    params?: TObject | ModelName;
    response?: TSchema | ModelName;
}
export type TypedWSSchemaToRoute<Schema extends WSTypedSchema = WSTypedSchema, Definitions extends ElysiaInstance['meta'][typeof DEFS] = {}> = {
    body: UnwrapSchema<Schema['body'], Definitions>;
    headers: UnwrapSchema<Schema['headers'], Definitions> extends infer Result extends Record<string, any> ? Result : undefined;
    query: UnwrapSchema<Schema['query'], Definitions> extends infer Result extends Record<string, any> ? Result : undefined;
    params: UnwrapSchema<Schema['params'], Definitions> extends infer Result extends Record<string, any> ? Result : undefined;
    response: UnwrapSchema<Schema['params'], Definitions> extends infer Result extends Record<string, any> ? Result : undefined;
};
export type WebSocketSchemaToRoute<Schema extends WSTypedSchema, Definitions extends ElysiaInstance['meta'][typeof DEFS] = {}> = {
    body: UnwrapSchema<Schema['body'], Definitions, undefined>;
    headers: UnwrapSchema<Schema['headers'], Definitions, undefined>;
    query: UnwrapSchema<Schema['query'], Definitions, undefined>;
    params: UnwrapSchema<Schema['params'], Definitions, undefined>;
    response: UnwrapSchema<Schema['response'], Definitions, undefined>;
};
export type TransformMessageHandler<Message extends WSTypedSchema['body']> = (message: UnwrapSchema<Message>) => void | UnwrapSchema<Message>;
export type ElysiaWSContext<Schema extends WSTypedSchema<any> = WSTypedSchema<never>, Definitions extends ElysiaInstance['meta'][typeof DEFS] = {}, Path extends string = never> = ServerWebSocket<Context<{
    body: UnwrapSchema<Schema['body'], Definitions, undefined>;
    headers: UnwrapSchema<Schema['headers'], Definitions, undefined>;
    query: UnwrapSchema<Schema['query'], Definitions, undefined>;
    params: ExtractPath<Path> extends infer Params extends string ? Record<Params, string> : UnwrapSchema<Schema['params'], Definitions, undefined>;
    response: UnwrapSchema<Schema['response'], Definitions, undefined>;
}> & {
    id: number;
    message: TypeCheck<any>;
    transformMessage: TransformMessageHandler<Schema['body']>[];
}>;
export type WebSocketHeaderHandler<Schema extends WSTypedSchema = WSTypedSchema, Path extends string = string> = (context: TypedWSSchemaToRoute<Schema>['params'] extends {} ? Omit<TypedWSSchemaToRoute<Schema>, 'response'> & {
    response: void | TypedWSSchemaToRoute<Schema>['response'];
} : Omit<Omit<TypedWSSchemaToRoute<Schema>, 'response'> & {
    response: void | TypedWSSchemaToRoute<Schema>['response'];
}, 'params'> & {
    params: Record<ExtractPath<Path>, string>;
}) => HeadersInit;
export type ElysiaWSOptions<Path extends string, Schema extends WSTypedSchema<any>, Definitions extends ElysiaInstance['meta'][typeof DEFS]> = Omit<Partial<WebSocketHandler<Context>>, 'open' | 'message' | 'close' | 'drain' | 'publish' | 'publishToSelf'> & (ElysiaWS<ElysiaWSContext<Schema, Definitions, Path>> extends infer WS ? Partial<Schema> & {
    beforeHandle?: WithArray<HookHandler<Schema>>;
    transform?: WithArray<NoReturnHandler<TypedWSSchemaToRoute<Schema>>>;
    transformMessage?: WithArray<TransformMessageHandler<Schema['body']>>;
    upgrade?: HeadersInit | WebSocketHeaderHandler<Schema>;
    open?: (ws: WS) => void | Promise<void>;
    message?: (ws: WS, message: UnwrapSchema<Schema['body'], Definitions>) => any;
    close?: (ws: WS, code: number, message: string) => void | Promise<void>;
    drain?: (ws: WS) => void | Promise<void>;
} : never);
