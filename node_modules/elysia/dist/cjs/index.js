"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalServerError = exports.ValidationError = exports.NotFoundError = exports.ParseError = exports.getResponseSchemaValidator = exports.mergeObjectArray = exports.mergeHook = exports.mergeDeep = exports.getSchemaValidator = exports.EXPOSED = exports.DEFS = exports.SCHEMA = exports.ws = exports.t = exports.Elysia = void 0;
const memoirist_1 = require("memoirist");
const utils_1 = require("./utils");
const schema_1 = require("./schema");
const compose_1 = require("./compose");
const ws_1 = require("./ws");
class Elysia {
    constructor(config) {
        this.store = {};
        this.meta = {
            [utils_1.SCHEMA]: Object.create(null),
            [utils_1.DEFS]: Object.create(null),
            [utils_1.EXPOSED]: Object.create(null)
        };
        this.decorators = {};
        this.event = {
            start: [],
            request: [],
            parse: [],
            transform: [],
            beforeHandle: [],
            afterHandle: [],
            error: [],
            stop: []
        };
        this.server = null;
        this.$schema = null;
        this.router = new memoirist_1.Memoirist();
        this.routes = [];
        this.staticRouter = {
            handlers: [],
            variables: '',
            map: {},
            all: ''
        };
        this.lazyLoadModules = [];
        this.handle = async (request) => this.fetch(request);
        this.fetch = (request) => (this.fetch = (0, compose_1.composeGeneralHandler)(this))(request);
        this.handleError = async (request, error, set) => (this.handleError = (0, compose_1.composeErrorHandler)(this))(request, error, set);
        this.outerErrorHandler = (error) => new Response(error.message, {
            status: error?.status ?? 500
        });
        this.listen = (options, callback) => {
            if (!Bun)
                throw new Error('Bun to run');
            this.compile();
            if (typeof options === 'string') {
                options = +options;
                if (Number.isNaN(options))
                    throw new Error('Port must be a numeric value');
            }
            const fetch = this.fetch;
            const development = (process.env.ENV ?? process.env.NODE_ENV) !== 'production';
            const serve = typeof options === 'object'
                ? {
                    ...this.config.serve,
                    ...options,
                    development,
                    fetch,
                    error: this.outerErrorHandler
                }
                : {
                    ...this.config.serve,
                    port: options,
                    fetch,
                    error: this.outerErrorHandler
                };
            if (development) {
                const key = `$$Elysia:${serve.port}`;
                if (globalThis[key]) {
                    this.server = globalThis[key];
                    this.server.reload(serve);
                }
                else {
                    globalThis[key] = this.server = Bun.serve(serve);
                }
            }
            else {
                this.server = Bun.serve(serve);
            }
            for (let i = 0; i < this.event.start.length; i++)
                this.event.start[i](this);
            if (callback)
                callback(this.server);
            Promise.all(this.lazyLoadModules).then(() => {
                Bun.gc(true);
            });
            return this;
        };
        this.stop = async () => {
            if (!this.server)
                throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
            this.server.stop();
            for (let i = 0; i < this.event.stop.length; i++)
                await this.event.stop[i](this);
        };
        this.config = {
            fn: '/~fn',
            forceErrorEncapsulation: false,
            basePath: '',
            ...config
        };
    }
    add(method, path, handler, hook, { allowMeta = false } = {
        allowMeta: false
    }) {
        path =
            path === '' ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
        if (this.config.basePath)
            this.config.basePath + path;
        this.routes.push({
            method,
            path,
            handler,
            hooks: (0, utils_1.mergeHook)({ ...this.event }, hook)
        });
        const defs = this.meta[utils_1.DEFS];
        if (hook?.type)
            switch (hook.type) {
                case 'text':
                    hook.type = 'text/plain';
                    break;
                case 'json':
                    hook.type = 'application/json';
                    break;
                case 'formdata':
                    hook.type = 'multipart/form-data';
                    break;
                case 'urlencoded':
                    hook.type = 'application/x-www-form-urlencoded';
                    break;
                case 'arrayBuffer':
                    hook.type = 'application/octet-stream';
                    break;
                default:
                    break;
            }
        (0, schema_1.registerSchemaPath)({
            schema: this.meta[utils_1.SCHEMA],
            contentType: hook?.type,
            hook,
            method,
            path,
            models: this.meta[utils_1.DEFS]
        });
        const validator = {
            body: (0, utils_1.getSchemaValidator)(hook?.body ?? this.$schema?.body, defs),
            headers: (0, utils_1.getSchemaValidator)(hook?.headers ?? this.$schema?.headers, defs, true),
            params: (0, utils_1.getSchemaValidator)(hook?.params ?? this.$schema?.params, defs),
            query: (0, utils_1.getSchemaValidator)(hook?.query ?? this.$schema?.query, defs),
            response: (0, utils_1.getResponseSchemaValidator)(hook?.response ?? this.$schema?.response, defs)
        };
        const hooks = (0, utils_1.mergeHook)(this.event, hook);
        const mainHandler = (0, compose_1.composeHandler)({
            path,
            method,
            hooks,
            validator,
            handler,
            handleError: this.handleError,
            meta: allowMeta ? this.meta : undefined,
            onRequest: this.event.request,
            config: this.config
        });
        if (path.indexOf(':') === -1 && path.indexOf('*') === -1) {
            const index = this.staticRouter.handlers.length;
            this.staticRouter.handlers.push(mainHandler);
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
            if (!this.staticRouter.map[path])
                this.staticRouter.map[path] = {
                    code: ''
                };
            if (method === 'ALL')
                this.staticRouter.map[path].all = `default: return st${index}(ctx)\n`;
            else
                this.staticRouter.map[path].code += `case '${method}': return st${index}(ctx)\n`;
        }
        else {
            this.router.add(method, path, mainHandler);
        }
    }
    onStart(handler) {
        this.event.start.push(handler);
        return this;
    }
    onRequest(handler) {
        this.event.request.push(handler);
        return this;
    }
    onParse(parser) {
        this.event.parse.splice(this.event.parse.length - 1, 0, parser);
        return this;
    }
    onTransform(handler) {
        this.event.transform.push(handler);
        return this;
    }
    onBeforeHandle(handler) {
        this.event.beforeHandle.push(handler);
        return this;
    }
    onAfterHandle(handler) {
        this.event.afterHandle.push(handler);
        return this;
    }
    onError(errorHandler) {
        this.event.error.push(errorHandler);
        return this;
    }
    onStop(handler) {
        this.event.stop.push(handler);
        return this;
    }
    on(type, handler) {
        switch (type) {
            case 'start':
                this.event.start.push(handler);
                break;
            case 'request':
                this.event.request.push(handler);
                break;
            case 'parse':
                this.event.parse.push(handler);
                break;
            case 'transform':
                this.event.transform.push(handler);
                break;
            case 'beforeHandle':
                this.event.beforeHandle.push(handler);
                break;
            case 'afterHandle':
                this.event.afterHandle.push(handler);
                break;
            case 'error':
                this.event.error.push(handler);
                break;
            case 'stop':
                this.event.stop.push(handler);
                break;
        }
        return this;
    }
    group(prefix, schemaOrRun, run) {
        const instance = new Elysia();
        instance.store = this.store;
        if (this.wsRouter)
            instance.use((0, ws_1.ws)());
        const isSchema = typeof schemaOrRun === 'object';
        const sandbox = (isSchema ? run : schemaOrRun)(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        this.model(sandbox.meta[utils_1.DEFS]);
        Object.values(instance.routes).forEach(({ method, path: originalPath, handler, hooks }) => {
            if (isSchema) {
                const hook = schemaOrRun;
                const localHook = hooks;
                const path = `${prefix}${originalPath}`;
                const hasWsRoute = instance.wsRouter?.find('subscribe', path);
                if (hasWsRoute) {
                    const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                    if (!wsRoute)
                        return;
                    return this.ws(path, wsRoute[2]);
                }
                this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                    ...localHook,
                    error: !localHook.error
                        ? sandbox.event.error
                        : Array.isArray(localHook.error)
                            ? [...localHook.error, ...sandbox.event.error]
                            : [localHook.error, ...sandbox.event.error]
                }));
            }
            else {
                const path = `${prefix}${originalPath}`;
                const hasWsRoute = instance.wsRouter?.find('subscribe', path);
                if (hasWsRoute) {
                    const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => originalPath === wsPath);
                    if (!wsRoute)
                        return;
                    return this.ws(path, wsRoute[2]);
                }
                this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                    error: sandbox.event.error
                }));
            }
        });
        if (instance.wsRouter && this.wsRouter)
            instance.wsRouter.history.forEach(([method, path, handler]) => {
                if (path === '/')
                    this.wsRouter?.add(method, prefix, handler);
                else
                    this.wsRouter?.add(method, `${prefix}${path}`, handler);
            });
        return this;
    }
    guard(hook, run) {
        const instance = new Elysia();
        instance.store = this.store;
        if (this.wsRouter)
            instance.use((0, ws_1.ws)());
        const sandbox = run(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        this.model(sandbox.meta[utils_1.DEFS]);
        Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
            const hasWsRoute = instance.wsRouter?.find('subscribe', path);
            if (hasWsRoute) {
                const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                if (!wsRoute)
                    return;
                return this.ws(path, wsRoute[2]);
            }
            this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                ...localHook,
                error: !localHook.error
                    ? sandbox.event.error
                    : Array.isArray(localHook.error)
                        ? [...localHook.error, ...sandbox.event.error]
                        : [localHook.error, ...sandbox.event.error]
            }));
        });
        if (instance.wsRouter && this.wsRouter)
            instance.wsRouter.history.forEach(([method, path, handler]) => {
                this.wsRouter?.add(method, path, handler);
            });
        return this;
    }
    use(plugin) {
        if (plugin instanceof Promise) {
            this.lazyLoadModules.push(plugin
                .then((plugin) => {
                if (typeof plugin === 'function')
                    return plugin(this);
                return plugin.default(this);
            })
                .then((x) => x.compile()));
            return this;
        }
        const instance = plugin(this);
        if (instance instanceof Promise) {
            this.lazyLoadModules.push(instance.then((x) => x.compile()));
            return this;
        }
        return instance;
    }
    if(condition, run) {
        if (!condition)
            return this;
        return this.use(run);
    }
    get(path, handler, hook) {
        this.add('GET', path, handler, hook);
        return this;
    }
    post(path, handler, hook) {
        this.add('POST', path, handler, hook);
        return this;
    }
    put(path, handler, hook) {
        this.add('PUT', path, handler, hook);
        return this;
    }
    patch(path, handler, hook) {
        this.add('PATCH', path, handler, hook);
        return this;
    }
    delete(path, handler, hook) {
        this.add('DELETE', path, handler, hook);
        return this;
    }
    options(path, handler, hook) {
        this.add('OPTIONS', path, handler, hook);
        return this;
    }
    all(path, handler, hook) {
        this.add('ALL', path, handler, hook);
        return this;
    }
    head(path, handler, hook) {
        this.add('HEAD', path, handler, hook);
        return this;
    }
    trace(path, handler, hook) {
        this.add('TRACE', path, handler, hook);
        return this;
    }
    connect(path, handler, hook) {
        this.add('CONNECT', path, handler, hook);
        return this;
    }
    ws(path, options) {
        if (!this.wsRouter)
            throw new Error("Can't find WebSocket. Please register WebSocket plugin first by importing 'elysia/ws'");
        this.wsRouter.add('subscribe', path, options);
        this.get(path, (context) => {
            if (this.server?.upgrade(context.request, {
                headers: typeof options.upgrade === 'function'
                    ? options.upgrade(context)
                    : options.upgrade,
                data: {
                    ...context,
                    id: Date.now(),
                    headers: context.request.headers.toJSON(),
                    message: (0, utils_1.getSchemaValidator)(options?.body, this.meta[utils_1.DEFS]),
                    transformMessage: !options.transform
                        ? []
                        : Array.isArray(options.transformMessage)
                            ? options.transformMessage
                            : [options.transformMessage]
                }
            }))
                return;
            context.set.status = 400;
            return 'Expected a websocket connection';
        }, {
            beforeHandle: options.beforeHandle,
            transform: options.transform,
            headers: options?.headers,
            params: options?.params,
            query: options?.query
        });
        return this;
    }
    route(method, path, handler, { config, ...hook } = {
        config: {
            allowMeta: false
        }
    }) {
        this.add(method, path, handler, hook, config);
        return this;
    }
    state(name, value) {
        if (typeof name === 'object') {
            this.store = (0, utils_1.mergeDeep)(this.store, name);
            return this;
        }
        if (!(name in this.store)) {
            ;
            this.store[name] =
                value;
        }
        return this;
    }
    decorate(name, value) {
        if (typeof name === 'object') {
            this.decorators = (0, utils_1.mergeDeep)(this.decorators, name);
            return this;
        }
        if (!(name in this.decorators))
            this.decorators[name] = value;
        return this;
    }
    derive(transform) {
        transform.$elysia = 'derive';
        return this.onTransform(transform);
    }
    fn(value) {
        return this.use(async (app) => {
            const { fn } = await Promise.resolve().then(() => __importStar(require('@elysiajs/fn')));
            if (typeof fn === undefined)
                throw new Error("Please install '@elysiajs/fn' before using Elysia Fn");
            return fn({
                app,
                value: value,
                path: app.config.fn
            });
        });
    }
    schema(schema) {
        const defs = this.meta[utils_1.DEFS];
        this.$schema = {
            body: (0, utils_1.getSchemaValidator)(schema.body, defs),
            headers: (0, utils_1.getSchemaValidator)(schema?.headers, defs, true),
            params: (0, utils_1.getSchemaValidator)(schema?.params, defs),
            query: (0, utils_1.getSchemaValidator)(schema?.query, defs),
            response: (0, utils_1.getSchemaValidator)(schema?.response, defs)
        };
        return this;
    }
    compile() {
        this.fetch = (0, compose_1.composeGeneralHandler)(this);
        if (this.server)
            this.server.reload({
                ...this.server,
                fetch: this.fetch
            });
        return this;
    }
    get modules() {
        return Promise.all(this.lazyLoadModules);
    }
    model(name, model) {
        if (typeof name === 'object')
            Object.entries(name).forEach(([key, value]) => {
                if (!(key in this.meta[utils_1.DEFS]))
                    this.meta[utils_1.DEFS][key] = value;
            });
        else
            this.meta[utils_1.DEFS][name] = model;
        return this;
    }
}
exports.default = Elysia;
exports.Elysia = Elysia;
var custom_types_1 = require("./custom-types");
Object.defineProperty(exports, "t", { enumerable: true, get: function () { return custom_types_1.t; } });
var ws_2 = require("./ws");
Object.defineProperty(exports, "ws", { enumerable: true, get: function () { return ws_2.ws; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "SCHEMA", { enumerable: true, get: function () { return utils_2.SCHEMA; } });
Object.defineProperty(exports, "DEFS", { enumerable: true, get: function () { return utils_2.DEFS; } });
Object.defineProperty(exports, "EXPOSED", { enumerable: true, get: function () { return utils_2.EXPOSED; } });
Object.defineProperty(exports, "getSchemaValidator", { enumerable: true, get: function () { return utils_2.getSchemaValidator; } });
Object.defineProperty(exports, "mergeDeep", { enumerable: true, get: function () { return utils_2.mergeDeep; } });
Object.defineProperty(exports, "mergeHook", { enumerable: true, get: function () { return utils_2.mergeHook; } });
Object.defineProperty(exports, "mergeObjectArray", { enumerable: true, get: function () { return utils_2.mergeObjectArray; } });
Object.defineProperty(exports, "getResponseSchemaValidator", { enumerable: true, get: function () { return utils_2.getResponseSchemaValidator; } });
var error_1 = require("./error");
Object.defineProperty(exports, "ParseError", { enumerable: true, get: function () { return error_1.ParseError; } });
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return error_1.NotFoundError; } });
Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return error_1.ValidationError; } });
Object.defineProperty(exports, "InternalServerError", { enumerable: true, get: function () { return error_1.InternalServerError; } });
