"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResponseSchemaValidator = exports.getSchemaValidator = exports.mergeDeep = exports.mergeHook = exports.mergeObjectArray = exports.EXPOSED = exports.DEFS = exports.SCHEMA = void 0;
const typebox_1 = require("@sinclair/typebox");
const compiler_1 = require("@sinclair/typebox/compiler");
exports.SCHEMA = Symbol('schema');
exports.DEFS = Symbol('definitions');
exports.EXPOSED = Symbol('exposed');
const mergeObjectArray = (a, b) => [
    ...(Array.isArray(a) ? a : [a]),
    ...(Array.isArray(b) ? b : [b])
];
exports.mergeObjectArray = mergeObjectArray;
const mergeHook = (a, b) => {
    return {
        body: b?.body ?? a?.body,
        headers: b?.headers ?? a?.headers,
        params: b?.params ?? a?.params,
        query: b?.query ?? a?.query,
        response: b?.response ?? a?.response,
        detail: (0, exports.mergeDeep)(b?.detail ?? {}, a?.detail ?? {}),
        transform: (0, exports.mergeObjectArray)(a.transform ?? [], b?.transform ?? []),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle ?? [], b?.beforeHandle ?? []),
        parse: (0, exports.mergeObjectArray)(a.parse ?? [], b?.parse ?? []),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle ?? [], b?.afterHandle ?? []),
        error: (0, exports.mergeObjectArray)(a.error ?? [], b?.error ?? []),
        type: a?.type || b?.type
    };
};
exports.mergeHook = mergeHook;
const isObject = (item) => item && typeof item === 'object' && !Array.isArray(item);
const mergeDeep = (target, source) => {
    const output = Object.assign({}, target);
    if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach((key) => {
            if (isObject(source[key])) {
                if (!(key in target))
                    Object.assign(output, { [key]: source[key] });
                else
                    output[key] = (0, exports.mergeDeep)(target[key], source[key]);
            }
            else {
                Object.assign(output, { [key]: source[key] });
            }
        });
    }
    return output;
};
exports.mergeDeep = mergeDeep;
const getSchemaValidator = (s, models, additionalProperties = false) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const schema = typeof s === 'string' ? models[s] : s;
    if (schema.type === 'object' && 'additionalProperties' in schema === false)
        schema.additionalProperties = additionalProperties;
    return compiler_1.TypeCompiler.Compile(schema);
};
exports.getSchemaValidator = getSchemaValidator;
const getResponseSchemaValidator = (s, models, additionalProperties = false) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s;
    if (typebox_1.Kind in maybeSchemaOrRecord)
        return {
            200: compiler_1.TypeCompiler.Compile(maybeSchemaOrRecord)
        };
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
        const maybeNameOrSchema = maybeSchemaOrRecord[status];
        if (typeof maybeNameOrSchema === 'string') {
            if (maybeNameOrSchema in models) {
                const schema = models[maybeNameOrSchema];
                schema.type === 'object' &&
                    'additionalProperties' in schema === false;
                record[+status] =
                    typebox_1.Kind in schema ? compiler_1.TypeCompiler.Compile(schema) : schema;
            }
            return undefined;
        }
        if (maybeNameOrSchema.type === 'object' &&
            'additionalProperties' in maybeNameOrSchema === false)
            maybeNameOrSchema.additionalProperties = additionalProperties;
        record[+status] =
            typebox_1.Kind in maybeNameOrSchema
                ? compiler_1.TypeCompiler.Compile(maybeNameOrSchema)
                : maybeNameOrSchema;
    });
    return record;
};
exports.getResponseSchemaValidator = getResponseSchemaValidator;
