import{parse as e}from"fast-querystring";import{mapEarlyResponse as r,mapResponse as t,mapCompactResponse as s}from"./handler";import{SCHEMA as n,DEFS as o}from"./utils";import{NotFoundError as a,ValidationError as c,InternalServerError as l}from"./error";let i="AsyncFunction",f=e=>e.constructor.name===i,u=new Headers,d=RegExp(" (\\w+) = context","g");export const hasReturn=e=>{let r=e.indexOf(")");return 61===e.charCodeAt(r+2)&&123!==e.charCodeAt(r+5)||e.includes("return")};let p=e=>({composeValidation:(r,t=`c.${r}`)=>e?`throw new ValidationError(
'${r}',
${r},
${t}
)`:`return new ValidationError(
	'${r}',
	${r},
	${t}
).toResponse(c.set.headers)`,composeResponseValidation:(r="r")=>e?`throw new ValidationError(
'response',
response[c.set.status],
${r}
)`:`return new ValidationError(
'response',
response[c.set.status],
${r}
).toResponse(c.set.headers)`});export const isFnUse=(e,r)=>{r=(r=r.trimStart()).replaceAll(/^async /g,"");let t=40===r.charCodeAt(0)||r.startsWith("function")?r.slice(r.indexOf("(")+1,r.indexOf(")")):r.slice(0,r.indexOf("=")-1);if(""===t)return!1;if(123===t.charCodeAt(0))return!!t.includes(e);if(r.match(RegExp(`${t}(.${e}|\\["${e}"\\])`)))return!0;let s=[t];for(let e of r.matchAll(d))s.push(e[1]);let n=RegExp(`{.*?} = (${s.join("|")})`,"g");for(let[t]of r.matchAll(n))if(t.includes(`{ ${e}`)||t.includes(`, ${e}`))return!0;return!1};export const findElysiaMeta=(e,r,t=[],s="")=>{if("object"===r.type){let n=r.properties;for(let r in n){let o=n[r],a=s?s+"."+r:r;if("object"===o.type){findElysiaMeta(e,o,t,a);continue}if(o.anyOf){for(let r of o.anyOf)findElysiaMeta(e,r,t,a);continue}o.elysiaMeta===e&&t.push(a)}return 0===t.length?null:t}return r?.elysiaMeta===e?(s&&t.push(s),"root"):null};let y=e=>{if(!e)return;let r=e?.schema;if(r&&"anyOf"in r){let e=!1,t=r.anyOf[0].type;for(let s of r.anyOf)if(s.type!==t){e=!0;break}if(!e)return t}};export const composeHandler=({method:d,hooks:m,validator:h,handler:$,handleError:b,meta:q,onRequest:E,config:g})=>{let w=g.forceErrorEncapsulation||m.error.length>0||"undefined"==typeof Bun,{composeValidation:x,composeResponseValidation:k}=p(w),H=w?"try {\n":"",R=h||"GET"!==d?[$,...m.transform,...m.beforeHandle,...m.afterHandle].map(e=>e.toString()):[],v="GET"!==d&&"none"!==m.type&&(h.body||m.type||R.some(e=>isFnUse("body",e))),O=h.headers||R.some(e=>isFnUse("headers",e));O&&(H+=u.toJSON?`c.headers = c.request.headers.toJSON()
`:`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`);let S=h.query||R.some(e=>isFnUse("query",e));S&&(H+=`const url = c.request.url

		if(c.query !== -1) {
			c.query = parseQuery(url.substring(c.query + 1))
		} else {
			c.query = {}
		}
		`);let C=R.some(e=>isFnUse("set",e))||E.some(e=>isFnUse("set",e.toString())),F=v||$.constructor.name===i||m.parse.length||m.afterHandle.find(f)||m.beforeHandle.find(f)||m.transform.find(f);if(v){let e=y(h?.body);if(m.type||e){if(m.type)switch(m.type){case"application/json":H+="c.body = JSON.parse(await c.request.text());";break;case"text/plain":H+="c.body = await c.request.text();";break;case"application/x-www-form-urlencoded":H+="c.body = parseQuery(await c.request.text());";break;case"application/octet-stream":H+="c.body = await c.request.arrayBuffer();";break;case"multipart/form-data":H+=`c.body = {}

					const form = await c.request.formData()
					for (const key of form.keys()) {
						if (c.body[key])
							continue

						const value = form.getAll(key)
						if (value.length === 1)
							c.body[key] = value[0]
						else c.body[key] = value
					}`}else if(e){let r=h?.body?.schema;"object"===e?"URLEncoded"===r.elysiaMeta?H+="c.body = parseQuery(await c.request.text())":h.body.Code().includes("custom('File")?H+=`c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue
		
								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}`:H+="c.body = JSON.parse(await c.request.text())":H+="c.body = await c.request.text()"}m.parse.length&&(H+="}}")}else{if(H+="\n"+(O?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')")+`
            if (contentType) {
				const index = contentType.indexOf(';')
				if (index !== -1) contentType = contentType.substring(0, index)
`,m.parse.length){H+=`let used = false
`;for(let e=0;e<m.parse.length;e++){let r=`bo${e}`;0!==e&&(H+=`if(!used) {
`),H+=`let ${r} = parse[${e}](c, contentType);if(${r} instanceof Promise) ${r} = await ${r};
						if(${r} !== undefined) { c.body = ${r}; used = true }
`,0!==e&&(H+="}")}H+="if (!used)"}H+=`switch (contentType) {
			case 'application/json':
				c.body = JSON.parse(await c.request.text())
				break

			case 'text/plain':
				c.body = await c.request.text()
				break

			case 'application/x-www-form-urlencoded':
				c.body = parseQuery(await c.request.text())
				break

			case 'application/octet-stream':
				c.body = await c.request.arrayBuffer();
				break

			case 'multipart/form-data':
				c.body = {}

				const form = await c.request.formData()
				for (const key of form.keys()) {
					if (c.body[key])
						continue

					const value = form.getAll(key)
					if (value.length === 1)
						c.body[key] = value[0]
					else c.body[key] = value
				}

				break
			}
		}
`}H+="\n"}if(h.params){let e=findElysiaMeta("Numeric",h.params.schema);if(e){if("object"==typeof e)for(let r of e)H+=`c.params.${r} = +c.params.${r};`;H+="\n"}}if(h.query){let e=findElysiaMeta("Numeric",h.query.schema);if(e){if("object"==typeof e)for(let r of e)H+=`c.query.${r} = +c.query.${r};`;H+="\n"}}if(h.headers){let e=findElysiaMeta("Numeric",h.headers.schema);if(e){if("object"==typeof e)for(let r of e)H+=`c.headers.${r} = +c.headers.${r};`;H+="\n"}}if(h.body){let e=findElysiaMeta("Numeric",h.body.schema);if(e){switch(typeof e){case"string":H+="c.body = +c.body;";break;case"object":for(let r of e)H+=`c.body.${r} = +c.body.${r};`}H+="\n"}}if(m?.transform)for(let e=0;e<m.transform.length;e++){let r=m.transform[e];"derive"===r.$elysia?H+=m.transform[e].constructor.name===i?`Object.assign(c, await transform[${e}](c));`:`Object.assign(c, transform[${e}](c));`:H+=m.transform[e].constructor.name===i?`await transform[${e}](c);`:`transform[${e}](c);`}if(h&&(h.headers&&(H+=`
                if (headers.Check(c.headers) === false) {
                    ${x("headers")}
				}
        `),h.params&&(H+=`if(params.Check(c.params) === false) { ${x("params")} }`),h.query&&(H+=`if(query.Check(c.query) === false) { ${x("query")} }`),h.body&&(H+=`if(body.Check(c.body) === false) { ${x("body")} }`)),m?.beforeHandle)for(let e=0;e<m.beforeHandle.length;e++){let r=`be${e}`,t=hasReturn(m.beforeHandle[e].toString());if(t){if(H+=(m.beforeHandle[e].constructor.name===i?`let ${r} = await beforeHandle[${e}](c);
`:`let ${r} = beforeHandle[${e}](c);
`)+`if(${r} !== undefined) {
`,m?.afterHandle)for(let e=0;e<m.afterHandle.length;e++){let t=hasReturn(m.afterHandle[e].toString());if(t){let t=`af${e}`;H+=(m.afterHandle[e].constructor.name===i?`const ${t} = await afterHandle[${e}](c, ${r});
`:`const ${t} = afterHandle[${e}](c, ${r});
`)+`if(${t} !== undefined) { ${r} = ${t} }
`}else H+=m.afterHandle[e].constructor.name===i?`await afterHandle[${e}](c, ${r});
`:`afterHandle[${e}](c, ${r});
`}h.response&&(H+=`if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
							${k(r)}
					}
`),H+=`return mapEarlyResponse(${r}, c.set)}
`}else H+=m.beforeHandle[e].constructor.name===i?`await beforeHandle[${e}](c);
`:`beforeHandle[${e}](c);
`}if(m?.afterHandle.length){H+=$.constructor.name===i?`let r = await handler(c);
`:`let r = handler(c);
`;for(let e=0;e<m.afterHandle.length;e++){let r=`af${e}`,t=hasReturn(m.afterHandle[e].toString());t?(H+=m.afterHandle[e].constructor.name===i?`let ${r} = await afterHandle[${e}](c, r)
`:`let ${r} = afterHandle[${e}](c, r)
`,h.response?H+=`if(${r} !== undefined) {if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
						${k(r)}
					}
${r} = mapEarlyResponse(${r}, c.set)
if(${r}) return ${r};
}`:H+=`if(${r}) return ${r};
`):H+=m.afterHandle[e].constructor.name===i?`await afterHandle[${e}](c, r)
`:`afterHandle[${e}](c, r)
`}h.response&&(H+=`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${k()}
			}
`),C?H+=`return mapResponse(r, c.set)
`:H+=`return mapCompactResponse(r)
`}else if(h.response)H+=($.constructor.name===i?`const r = await handler(c);
`:`const r = handler(c);
`)+`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${k()}
			}
`,C?H+=`return mapResponse(r, c.set)
`:H+=`return mapCompactResponse(r)
`;else{let e=$.constructor.name===i?"await handler(c) ":"handler(c)";C?H+=`return mapResponse(${e}, c.set)
`:H+=`return mapCompactResponse(${e})
`}w&&(H+=`
} catch(error) {
	

	${F?"":"return (async () => {"}
		const set = c.set

		if (!set.status || set.status < 300) set.status = 500

		${m.error.length?`for (let i = 0; i < handleErrors.length; i++) {
				let handled = handleErrors[i]({
					request: c.request,
					error: error,
					set,
					code: error.code ?? "UNKNOWN"
				})
				if (handled instanceof Promise) handled = await handled

				const response = mapEarlyResponse(handled, set)
				if (response) return response
			}`:""}

		return handleError(c.request, error, set)
	${F?"":"})()"}
}`),H=`const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors
		},
		validator: {
			body,
			headers,
			params,
			query,
			response
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		${q?`
			meta,
			SCHEMA,
			DEFS,`:""}
	} = hooks

	return ${F?"async":""} function(c) {
		${q?"c[SCHEMA] = meta[SCHEMA]; c[DEFS] = meta[DEFS];":""}
		${H}
	}`;let N=Function("hooks",H);return N({handler:$,hooks:m,validator:h,handleError:b,utils:{mapResponse:t,mapCompactResponse:s,mapEarlyResponse:r,parseQuery:e},error:{NotFoundError:a,ValidationError:c,InternalServerError:l},meta:q,SCHEMA:q?n:void 0,DEFS:q?o:void 0})};export const composeGeneralHandler=e=>{let t="";for(let r of Object.keys(e.decorators))t+=`,${r}: app.decorators.${r}`;let{router:s,staticRouter:n}=e,o=`
	const route = find(request.method, path) ${s.root.ALL?'?? find("ALL", path)':""}
	if (route === null)
		return ${e.event.error.length?`handleError(
			request,
			notFound,
			ctx.set
		)`:`new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`,c="";for(let[e,{code:r,all:t}]of Object.entries(n.map))c+=`case '${e}':
switch(request.method) {
${r}
${t??`default: ${o}`}}

`;let l=`const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError
	} = data

	const notFound = new NotFoundError()

	${e.event.request.length?"const onRequest = app.event.request":""}

	${n.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${e.event.error.length?"":"const error404 = notFound.message.toString()"}

	return function(request) {
	`;if(e.event.request.length){l+=`
			const ctx = {
				request,
				store,
				set: {
					headers: {},
					status: 200
				}
				${t}
			}

			try {
`;for(let r=0;r<e.event.request.length;r++){let t=hasReturn(e.event.request[r].toString());l+=t?`const response = mapEarlyResponse(
					onRequest[${r}](ctx),
					ctx.set
				)
				if (response) return response
`:`mapEarlyResponse(onRequest[${r}](ctx), ctx.set);`}l+=`} catch (error) {
			return handleError(request, error, ctx.set)
		}
		
		const url = request.url,
		s = url.indexOf('/', 12),
		i = ctx.query = url.indexOf('?', s + 1),
		path = i === -1 ? url.substring(s) : url.substring(s, i);`}else l+=`
			const url = request.url,
			s = url.indexOf('/', 12)

		const ctx = {
			request,
			store,
			query: url.indexOf('?', s + 1),
			set: {
				headers: {},
				status: 200
			}
			${t}
		}

		const path =
			ctx.query === -1
				? url.substring(s)
				: url.substring(s, ctx.query);`;return l+=`
		switch(path) {
			${c}

			default:
				${o}
		}
	}`,e.handleError=composeErrorHandler(e),Function("data",l)({app:e,mapEarlyResponse:r,NotFoundError:a})};export const composeErrorHandler=e=>{let r=`const {
		app: { event: { error: onError } },
		mapResponse
	} = inject
	
	return ${e.event.error.find(e=>e.constructor.name===i)?"async":""} function(request, error, set) {`;for(let t=0;t<e.event.error.length;t++){let s=e.event.error[t],n=`${s.constructor.name===i?"await ":""}onError[${t}]({
			request,
			code: error.code ?? 'UNKNOWN',
			error,
			set
		})`;hasReturn(s.toString())?r+=`const r${t} = ${n}; if(r${t} !== null) return mapResponse(r${t}, set)
`:r+=n+"\n"}return Function("inject",r+=`return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
}`)({app:e,mapResponse:t})};